// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

/**
 * @title AtomicSwap
 * @notice A contract for conducting atomic swaps between ERC20 tokens
 * @dev Supports initiation, acceptance, and cancellation of token swaps
 */
contract AtomicSwap {
    struct Swap {
        bool isAccepted;
        address userA;
        address userB;
        address tokenA;
        address tokenB;
        uint256 amountA;
        uint256 amountB;
    }

    mapping(bytes32 => Swap) public swaps;

    // Events
    event SwapInitiated(
        uint256 swapId,
        address indexed userA,
        address indexed userB,
        address tokenA,
        address tokenB,
        uint256 amountA,
        uint256 amountB,
        uint256 timestamp
    );
    event SwapAccepted(
        uint256 indexed swapId, address indexed userA, address indexed userB, uint256 timestamp
    );
    event SwapCancelled(uint256 indexed swapId, address indexed userA, uint256 timestamp);

    /**
     * @notice Initiates a new swap
     * @param userB The address of User B
     * @param tokenA The address of token A
     * @param tokenB The address of token B
     * @param amountA The amount of token A
     * @param amountB The amount of token B
     */
    function initiateSwap(
        address userB,
        address tokenA,
        address tokenB,
        uint256 amountA,
        uint256 amountB
    ) external {
        // ensure userA owns the amount of tokenA they want to swap
        require(
            IERC20(tokenA).balanceOf(msg.sender) >= amountA, "User A does not have enough token A"
        );

        // ensure userB owns the amount of tokenB they want to swap
        require(IERC20(tokenB).balanceOf(userB) >= amountB, "User B does not have enough token B");

        // calculating swapId using keccak256 ensures that the swapId is unique
        // also, it can be generated by both parties without the need to communicate
        bytes32 swapId =
            keccak256(abi.encodePacked(msg.sender, userB, tokenA, tokenB, amountA, amountB));
        require(swaps[swapId].userA == address(0), "Swap already initiated");

        emit SwapInitiated(
            uint256(swapId), msg.sender, userB, tokenA, tokenB, amountA, amountB, block.timestamp
        );

        swaps[swapId] = Swap(false, msg.sender, userB, tokenA, tokenB, amountA, amountB);
    }

    /**
     * @notice Initiates a new swap with a unique salt
     * @param userB The address of User B
     * @param tokenA The address of token A
     * @param tokenB The address of token B
     * @param amountA The amount of token A
     * @param amountB The amount of token B
     * @param salt A random salt to ensure uniqueness of swapId
     * @return swapId The unique identifier of the swap
     */
    function initiateSwap(
        address userB,
        address tokenA,
        address tokenB,
        uint256 amountA,
        uint256 amountB,
        bytes32 salt
    ) external returns (bytes32) {
        // for situations where repeated swaps between same users of exactly the same tokens and amounts are needed
        bytes32 swapId =
            keccak256(abi.encodePacked(msg.sender, userB, tokenA, tokenB, amountA, amountB, salt));
        require(swaps[swapId].userA == address(0), "Swap already initiated");

        swaps[swapId] = Swap(false, msg.sender, userB, tokenA, tokenB, amountA, amountB);

        emit SwapInitiated(
            uint256(swapId), msg.sender, userB, tokenA, tokenB, amountA, amountB, block.timestamp
        );

        return swapId;
    }

    /**
     * @notice Accepts an existing swap
     * @param swapId The unique identifier of the swap
     */
    function acceptSwap(bytes32 swapId) external {
        Swap memory swap = swaps[swapId];

        require(swap.userB == msg.sender, "Unauthorized");
        require(swap.isAccepted == false, "Swap already accepted");

        // update swap isAccepted, this will prevent reentrancy
        swap.isAccepted = true;
        swaps[swapId] = swap;

        require(
            IERC20(swap.tokenA).transferFrom(swap.userA, msg.sender, swap.amountA),
            "Transfer of tokenA failed"
        );
        require(
            IERC20(swap.tokenB).transferFrom(msg.sender, swap.userA, swap.amountB),
            "Transfer of tokenB failed"
        );

        emit SwapAccepted(uint256(swapId), swap.userA, swap.userB, block.timestamp);
    }

    /**
     * @notice Cancels an existing swap by User A
     * @param swapId The unique identifier of the swap
     */
    function cancelSwap(bytes32 swapId) public {
        Swap storage swap = swaps[swapId];
        // only userA can cancel the swap
        require(swap.userA == msg.sender, "Unauthorized");
        // only if the swap is not accepted
        require(swap.isAccepted == false, "Swap already accepted");
        // cancel the swap
        delete swaps[swapId];

        emit SwapCancelled(uint256(swapId), swap.userA, block.timestamp);
    }

    /**
     * @notice Retrieves details of a specific swap
     * @param swapId The unique identifier of the swap
     * @return Swap The swap details
     */
    function getSwap(bytes32 swapId) external view returns (Swap memory) {
        return swaps[swapId];
    }
}
